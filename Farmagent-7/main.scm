;Assumption: agent state = (50, 50, n, 10000)
(define agent-state '((50 50 n 10000)))
(define actions '("move-passive-1" "move-passive-2" "move-passive-3" "turn-right" "turn-left" "turn-around" "stay")) 
(define vist (make-array 0 100 100))
(define grid (make-array 0 100 100))
(define path '())
(define initial 'false)
(define veg-exists 0)
(define path-length 0)
(define turn-track 0)
;Variables for Information Gathering
(define veg-gather-start 'false)
(define vegetations '())
(define predators '())
(define dimensions '())
(define num-turns 0)
(define dimension-monitor 'false)
(define vertical-done 0)
(define next-action 's)
(define percept-count '(3 5 7 9 11))
;Natural Selection
(define turn 0)
(define cur-agents '())
(define cur-predators '())
(define (initialize-agent) "OK")

;*********************** Natural Selection  ************************
		
(define (choose-action energy last_evt percepts)
		(set! cur-agents '())
		(set! cur-predators '()) 
		(parse-lastevt last_evt)
		(parse-percepts percepts)
		(if(eq? (+ 1 turn-track) path-length) (begin (clear-vist) (set! turn-track 0) (set! path-length 0) (set! path '()))) 
		(cond 	((eq? path-length 0) (begin 	(bfs agent-state)
							(if(eq? path-length 0) (rescue-plan-noveg) 
								(begin (set! turn 0) (display-actions (return-safe-action (car path)))))))
			((< (+ turn-track 1) path-length) (begin (set! turn-track (+ turn-track 1))
							(display-actions (return-safe-action (list-ref path turn-track)))))
			(#t (display-actions 'l))))

;Strategy to come out of deadlock situation in case of no vegetation around.
(define (rescue-plan-noveg)
	(clear-vist) 
	(set! turn (+ turn 1))
	(cond 	((> turn 8) (begin (set! turn 0) (display-actions 'l)))
		((> turn 4) (if(not(null? (generate-moves-helper (car agent-state) "move-passive-1"))) 
				(display-actions 'm1) (display-actions 'l))) 
		(#t (display-actions (return-safe-action 'l)))))

;Agent: unsafe to stay or turn - run away from predator
(define (run-away state sym)
	(if(not(null? (generate-moves-helper state "move-passive-1"))) 'm1 sym)) ;(begin (display "runaway= m1") (newline) 'm1) sym))

;Safe Play functions - Agent move cautiously before taking any step 
(define (return-safe-action sym)
		(cond 	((or (eq? sym 'm1) (eq? sym 'm2) (eq? sym 'm3))
			(cond ((and (eq? sym 'm1) (is-safe-move-aggressive (car agent-state) 1)) 'ma1)
				((and (eq? sym 'm2) (is-safe-move-aggressive (car agent-state) 2)) 'ma2)
				((and (eq? sym 'm3) (is-safe-move-aggressive (car agent-state) 3)) 'ma3)
				((and (eq? sym 'm1) (is-safe-move-passive (car agent-state) 1)) 'm1)
				((and (eq? sym 'm2) (is-safe-move-passive (car agent-state) 2)) 'm2)
				((and (eq? sym 'm3) (is-safe-move-passive (car agent-state) 3)) 'm3)
				(#t 'a)))
		((eq? sym 'ep) (if(is-safe-eat-aggressive (car agent-state)) 'ea 'ep))
		(#t  (if(eq? (is-safe-stay-turn (car agent-state)) #f) (run-away (car agent-state) sym) sym)))) ;run-away from predator)))

(define (is-safe-move-aggressive state moves)
	(let ((newstate (list-copy (get-state state moves))))
		(if(> (cal-adj-agents newstate) 0) 
			(if(eq? (is-agent-strongest (cadddr state) (get-adjagents-egylst newstate)) #t) #t #f) #f)))

(define (is-safe-move-passive state moves)
	(let ((newstate (list-copy (get-state state moves))))
		(if(or (> (cal-adj-pred newstate) 0) (> (cal-adj-agents newstate) 0)) #f #t)))

(define (is-safe-eat-aggressive state)
	(let ((newstate (list-copy (get-state state 1))))
		(if(> (cal-adj-agents newstate) 0) 
			(if(eq? (is-agent-strongest (cadddr state) (get-adjagents-egylst newstate)) #t) #t #f) #f)))

(define (is-safe-stay-turn state)
	(let ((newstate (list-copy (apply-move state "stay"))))
		(if(> (cal-around-pred newstate) 0) #f #t)))

;Utility Functions
(define (check-agent-pred state)
		(if(or (exists-agent state cur-agents) (exists-pred state cur-predators)) #t #f))

(define (exists-agent state agentlst)
	(cond ((null? agentlst) #f)
		(#t	(if(and (eq? (car state) (cadr (car agentlst))) 
				(eq? (cadr state) (caddr (car agentlst)))) 
				#t (exists-agent state (cdr agentlst))))))

(define (exists-pred state predlst)
	(cond ((null? predlst) #f)
		(#t	(if(and (eq? (car state) (car (car predlst))) 
				(eq? (cadr state) (cadr (car predlst)))) 
				#t (exists-pred state (cdr predlst))))))

(define (add-cur-predator sym x y)
			(set! cur-predators (cons (list x y (cadr sym)) cur-predators)))		

(define (add-cur-agent sym x y)
		(if (eq? (assq (cadr sym) cur-agents) #f)
			(set! cur-agents (cons (list (cadr sym) x y (caddr sym) (cadddr sym)) cur-agents))))			

(define (check-agent-helper x y dir agentlst)
	(cond ((null? agentlst) #f)
		(#t	(if(and (eq? (cadr (car agentlst)) x) (eq? (caddr (car agentlst)) y)
				(eq? (list-ref (car agentlst) 4) dir)) #t (check-agent-helper x y dir (cdr agentlst))))))
(define (check-agent x y dir)
		(if(eq? (check-agent-helper x y dir cur-agents) #t) 1 0))	

(define (check-pred-helper x y predlst)
	(cond ((null? predlst) #f)
		(#t	(if(and (eq? (car (car predlst)) x) (eq? (cadr (car predlst)) y)) 
					#t (check-pred-helper x y (cdr predlst))))))
(define (check-pred x y)
		(if(eq? (check-pred-helper x y cur-predators) #t) 1 0))	
		
(define (cal-adj-agents state)
	(cond ((eq? (caddr state) 'n)	
			(+ (check-agent (- (car state) 1) (cadr state) 'right)
				(check-agent (+ (car state) 1) (cadr state) 'left)
				(check-agent (car state) (- (cadr state) 1) 'towards)))
	((eq? (caddr state) 'e)	
			(+ (check-agent (+ (car state) 1) (cadr state) 'towards)
				(check-agent (car state) (+ (cadr state) 1) 'left)
				(check-agent (car state) (- (cadr state) 1) 'right)))
	((eq? (caddr state) 'w)	
			(+ (check-agent (- (car state) 1) (cadr state) 'towards)
				(check-agent (car state) (- (cadr state) 1) 'left)
				(check-agent (car state) (+ (cadr state) 1) 'right)))
	((eq? (caddr state) 's)	
			(+ (check-agent (- (car state) 1) (cadr state) 'left)
				(check-agent (+ (car state) 1) (cadr state) 'right)
				(check-agent (car state) (+ (cadr state) 1) 'towards)))))
	
(define (ret-agent-energy x y dir agentlst)
	(cond ((null? agentlst) 0)
		(#t	(if(and (eq? (cadr (car agentlst)) x) (eq? (caddr (car agentlst)) y)
				(eq? (list-ref (car agentlst) 4) dir)) (list-ref (car agentlst) 3) 
									(ret-agent-energy x y dir (cdr agentlst))))))
(define (agent-energy x y dir energy-lst)
		(let ((energy (ret-agent-energy x y dir cur-agents)))
				(if(> energy 0) (cons energy energy-lst) energy-lst)))
				
(define (get-adjagents-egylst state)
	(let ((lst '()))
		(cond ((eq? (caddr state) 'n)
				(set! lst (agent-energy (- (car state) 1) (cadr state) 'right lst))
				(set! lst (agent-energy (+ (car state) 1) (cadr state) 'left lst))
				(set! lst (agent-energy (car state) (- (cadr state) 1) 'towards lst)))
			((eq? (caddr state) 'e)	
				(set! lst (agent-energy (+ (car state) 1) (cadr state) 'towards lst))
				(set! lst (agent-energy (car state) (- (cadr state) 1) 'right lst))
				(set! lst (agent-energy (car state) (+ (cadr state) 1) 'left lst)))
			((eq? (caddr state) 'w)	
				(set! lst (agent-energy (- (car state) 1) (cadr state) 'towards lst))
				(set! lst (agent-energy (car state) (+ (cadr state) 1) 'right lst))
				(set! lst (agent-energy (car state) (- (cadr state) 1) 'left lst)))
			((eq? (caddr state) 's)	
				(set! lst (agent-energy (+ (car state) 1) (cadr state) 'right lst))
				(set! lst (agent-energy (- (car state) 1) (cadr state) 'left lst))
				(set! lst (agent-energy (car state) (+ (cadr state) 1) 'towards lst))))
				lst ))

(define (is-agent-strongest agent-egy adj-agent-egy-lst)
		(if(> agent-egy (car (sort adj-agent-egy-lst >))) #t #f))

(define (cal-adj-pred state)
	(cond ((eq? (caddr state) 'n)	
			(+ (check-pred (- (car state) 1) (cadr state))
				(check-pred (+ (car state) 1) (cadr state))
				(check-pred (car state) (- (cadr state) 1))))
	((eq? (caddr state) 'e)	
			(+ (check-pred (+ (car state) 1) (cadr state))
				(check-pred (car state) (+ (cadr state) 1))
				(check-pred (car state) (- (cadr state) 1))))
	((eq? (caddr state) 'w)	
			(+ (check-pred (- (car state) 1) (cadr state))
				(check-pred (car state) (- (cadr state) 1))
				(check-pred (car state) (+ (cadr state) 1))))
	((eq? (caddr state) 's)	
			(+ (check-pred (- (car state) 1) (cadr state))
				(check-pred (+ (car state) 1) (cadr state))
				(check-pred (car state) (+ (cadr state) 1))))))
 
(define (cal-around-pred state)
		(+ (check-pred (- (car state) 1) (cadr state))
				(check-pred (+ (car state) 1) (cadr state))
				(check-pred (car state) (+ (cadr state) 1))
				(check-pred (car state) (- (cadr state) 1))))
 
(define (get-state state moves) 
	(cond ((eq? moves 1) (apply-move state "move-passive-1"))
		((eq? moves 2) (apply-move state "move-passive-2"))
		((eq? moves 3) (apply-move state "move-passive-3"))))

;clear the visited array
(define (clear-vist)
	(let oloop((i 0))
		(let iloop((j 0))
		(array-set! vist 0 i j)
		(if(< j 99) (iloop (+ j 1))))
		(if(< i 99) (oloop (+ i 1)))))


;****************************************************************************
;****************** Information Gathering Module ****************************
;****************************************************************************
;
;(define (choose-action energy last_evt percepts) 
;		(parse-lastevt last_evt)
;		(parse-percepts percepts)
;		(set! num-turns (+ num-turns 1))
;		(if(> num-turns 50) (begin (set! num-turns 0)
;						(report-intel))
;			(if(eq? veg-gather-start 'true) (display-actions 's) (display-actions 'm1)))) 

; Main Functions for displaying gathered information
(define (get-vegetation-info veglst) 
	(cond ((null? veglst) "")
		(#t (string-append (get-veg-info (car veglst)) (get-vegetation-info (cdr veglst))))))
	
(define (get-predator-info predatorlst)
	(cond ((null? predatorlst) "")
		(#t   	(string-append (get-pred-info (car predatorlst)) (get-predator-info (cdr predatorlst))))))

(define (get-coordinates-info)
	(cond ((null? dimensions) "")
		(#t	(if(> (car dimensions) 0)
				(string-append " XDIM:" (number->string (car dimensions)) 
						" YDIM:" (number->string (car dimensions)))))))
	
(define (report-intel)
	(string-append "REPORT-INTEL"  (get-coordinates-info) 
				(get-vegetation-info (get-monitored-veg vegetations)) 
				(get-predator-info predators)))
 
; Utility functions for display
(define (get-monitored-veg veglist)
	(cond ((null? veglist) '())
		(#t (if(eq? (list-ref (car veglist) 3) 0) (cons (car veglist) (get-monitored-veg (cdr veglist))) 
								(get-monitored-veg (cdr veglist)))))) 
	
(define (get-bloom-cycle lst)
	(cond ((null? lst) "")
		(#t (string-append (number->string (car lst)) " " (get-bloom-cycle (cdr lst))))))

(define (get-veg-info veg)	
	(cond ((null? veg) "")
		(#t	(let ((id (car veg)))
			(string-append " VEG-FREQ(" (number->string id) "):" (number->string (list-ref veg 4))
					" VEG-CYCLE(" (number->string id) "):" (number->string (list-ref veg 6))
				 	" VEG-INCUBATION(" (number->string id) "):" (number->string (list-ref veg 5))
					" VEG-BLOOM(" (number->string id) "):" (get-bloom-cycle (list-tail veg 7)))))))

(define (get-pred-info pred)
	(cond ((null? pred) "")
		(#t	(string-append " PRED-DAMAGE(" (number->string (car pred)) "):" (number->string (cadr pred))))))

; Main functions for Vegetation information
; This function calculates vegetation frequency, cycle, incubation and blooming cycle.
(define (cal-veg-cycle veglst)
	(set! veg-gather-start 'false)
	(let ((veg-cycle (sort (list-tail veglst 7) <))) 
		(let ((num-incub (count-incubation veg-cycle)))
			(append (list (car veglst) (cadr veglst) (caddr veglst) 0 
				(round-off (exact->inexact (/ (cal-veg-freq (car veglst)) (cal-explored-region))) 3) 
				num-incub (+ num-incub (length (list-tail veg-cycle num-incub)))) 
				(append (even-numbers-lst (list-tail veg-cycle num-incub)) 
					(sort (odd-numbers-lst (list-tail veg-cycle num-incub)) >))))))

(define (incr-veg veglist id energy xloc yloc)
	(cond ((null? veglist) '())
		(#t (if(eq? (check-veg (car veglist) id xloc yloc) #t)
				(begin (if(> (cadddr (car veglist)) 1)
						(if(eq? (cadddr (car veglist)) energy) 
							(cons (cal-veg-cycle (car veglist)) (cdr veglist))
							(cons (append (car veglist) (list energy)) (cdr veglist))) 
						(list (car veglist))))
				(cons (car veglist) (incr-veg (cdr veglist) id energy xloc yloc))))))
	;			(cons (replace-nth 2 (+ (list-ref (car veglist) 1) 1) (car veglist)) (cdr veglist))

(define (check-veg veg id xloc yloc)  
	(if(and (eq? (car veg) id) (eq? (cadr veg) xloc) (eq? (caddr veg) yloc) ) #t #f))

;(vegetation list structure) - (id xloc yloc Monitor Freq incubation veg-cycle bloom-cyle)
;value of monitor - zero indicates its monitored and non-zero value tells the point of monitoring
(define (get-vegetation sym xloc yloc)
		(list (list-ref sym 1) xloc yloc (list-ref sym 2) 0 0 0 (list-ref sym 2)))

(define (add-vegetation sym xloc yloc)
		(if (eq? (assq (list-ref sym 1) vegetations) #f)
			(begin 
				(if(> (list-ref sym 2) 1)
					(begin (set! veg-gather-start 'true)
					(set! vegetations (append vegetations (list (get-vegetation sym xloc yloc)))))))
				(begin 
					(let ((veglst (incr-veg vegetations (list-ref sym 1) (list-ref sym 2) xloc yloc)))
					(if(not(null? veglst)) (set! vegetations veglst))))))

; Utility functions for Vegetation
(define (replace-nth count newval lst)
	(cond ((= count 1) (cons newval (cdr lst)))
		(#t (cons (car lst) (replace-nth (- count 1) newval (cdr lst))))))

(define (count-incubation lst)
		(cond ((null? lst) 0)	
			(#t (if(eq? (car lst) 0) (+ 1 (count-incubation (cdr lst))) 0))))

(define (odd-numbers-lst lst)	
		(cond ((null? lst) '())
			(#t (if(odd? (car lst)) (cons (car lst) (odd-numbers-lst (cdr lst))) (odd-numbers-lst (cdr lst))))))

(define (even-numbers-lst lst)	
		(cond ((null? lst) '())
			(#t (if(even? (car lst)) (cons (car lst) (even-numbers-lst (cdr lst))) (even-numbers-lst (cdr lst))))))

(define (veg-freq-helper id x y)
	(let ((sym (array-ref grid x y)))
		(if(and (list? sym) (eq? (cadr sym) id)) #t #f)))

(define (round-off num n)
	(let ((power (expt 10 n)))
		(/ (round (* power num)) power)))

(define (cal-veg-freq veg-id)
	(let ((count 0))
		(let oloop((i 0))
			(let iloop((j 0))
				(if(eq? (veg-freq-helper veg-id i j) #t) (set! count (+ count 1)))
			(if(< j 99) (iloop (+ j 1))))
			(if(< i 99) (oloop (+ i 1))))
		count))

(define (cal-explored-region)
	(let ((count 0))
		(let oloop((i 0))
			(let iloop((j 0))
				(if(eq? (array-ref grid i j) 'x) (set! count (+ count 1)))
			(if(< j 99) (iloop (+ j 1))))
			(if(< i 99) (oloop (+ i 1))))
		(- 10000 count)))

; Main functions for Predators information
(define (get-predator last_evt) 
		(list (list-ref last_evt 1) (abs (list-ref last_evt 2))))

(define (add-predator last_evt)
		(if (eq? (assq (list-ref last_evt 1) predators) #f)
			(set! predators (append predators (list (get-predator last_evt))))))

; Main function for X,Y Dimensions.
(define (reached-terminal-helper percept)
	(cond ((null? percept) 0)
		(#t (if(eq? (car percept) 'barrier) (+ 1 (reached-terminal-helper (cdr percept))) 0))))
	
(define (reached-terminal percept num)
		(if(eq? (reached-terminal-helper percept) num) #t #f))

(define (dist-to-terminal percepts percept-count)
	(cond ((null? percepts) 0)
		(#t (if(eq? (reached-terminal (car percepts) (car percept-count)) #t) 
				0 (+ 1 (dist-to-terminal (cdr percepts) (cdr percept-count)))))))

(define (calculate-dimensions percepts)
	(if(eq? (reached-terminal (list-ref percepts 4) (list-ref percept-count 4)) #t)
			(begin 
				(set! turn-track 0) (set! path-length 2) (set! path '(s a))
				(set! vertical-done (+ 1 vertical-done))
				(if(eq? vertical-done 1) (list-set! dimensions 0 (dist-to-terminal percepts percept-count)))
				(if(eq? vertical-done 2) 
					(begin (set! dimension-monitor 'true) 	
						(list-set! dimensions 0 (+ (car dimensions) (dist-to-terminal percepts percept-count))))))
;				(if(eq? vertical-done 'false) (+ (cadr dimensions) (dist-to-terminal percepts percept-count))
;							(+ (car dimensions) (dist-to-terminal percepts)))
;				(if(eq? vertical-done 'false) (set! next-action 'a) (set! next-action 'l))
;				(set! vertical-done (+ 1 vertical-done)))
			(if(< path-length 3)  
				(begin (display (car agent-state)) 
					(if(null? (generate-moves-helper (car agent-state) (list-ref actions 2))) 
						(begin (set! turn-track 0) (set! path-length 4) (set! path '(s l m1 r))) 
						(begin (list-set! dimensions 0 (+ (car dimensions) 3)) 
							(set! turn-track 0) (set! path-length 2) (set! path '(s m3)))))))) 

(define (update-agent-pos spaces)
	(cond ((eq? (caddr (car agent-state)) 'n) (list-set! (car agent-state) 1 (- (cadr (car agent-state)) spaces))) 	
		((eq? (caddr (car agent-state)) 'w) (list-set! (car agent-state) 0 (- (car (car agent-state)) spaces))) 	
		((eq? (caddr (car agent-state)) 'e) (list-set! (car agent-state) 0 (+ (car (car agent-state)) spaces))) 	
		((eq? (caddr (car agent-state)) 's) (list-set! (car agent-state) 1 (+ (cadr (car agent-state)) spaces))))) 	

(define (parse-lastevt last_evt)
	(cond ((null? last_evt))
		((eq? (car (car last_evt)) 'attacked-by) (add-predator (car last_evt)))))
	;	((eq? (car (car last_evt)) 'moved) (update-agent-pos (cadr (car last_evt))))))

;******************************Information Gathering End ******************************

;******************************Searching Algorithms ******************************

;(define choose-action energy last_evt percepts)
;		(cond ((eq? initial 'false) 
;			(begin (parseEnv percepts) (set! initial 'true) (bfs agent-state)
;						(if(= path-length 0) (display-actions 'ep) 
;							(display-actions (list-ref path turn-track)))))
;			((< (+ turn-track 1) path-length) 
;					(begin (set! turn-track (+ turn-track 1)) (display-actions (list-ref path turn-track))))
;			(#t (display-actions 'ep))))

; Search Algorithms
; Breadth-first search
(define (bfs queue)
	(if(not(null? queue)) 
		(if(test-goal (car queue)) (solution-path(car queue))
			(let ((childs (list-copy(generate-moves (car queue) actions)))) 
			(array-set! vist 1 (list-ref (car queue) 0) (list-ref (car queue) 1))
			(if(null? (cdr queue)) (bfs childs) 
						(bfs (append (cdr queue) childs)))))))
;Uniform cost search
(define (ucs queue)
	(if(not(null? queue)) 
		(if(test-goal (car queue)) (solution-path(car queue))
			(let ((childs (list-copy(generate-moves (car queue) actions)))) 
			(array-set! vist 1 (list-ref (car queue) 0) (list-ref (car queue) 1))
			(if(null? (cdr queue)) (ucs (energy-sort childs)) 
						(ucs (energy-sort (append (cdr queue) childs))))))))

; Main functions
; This function tests whether agent reach goal state or not
(define (test-goal state)
	(let ((newstate (list-copy (apply-move state "eat-passive")))) 
		(if (> (abs(- (list-ref newstate 3) (list-ref state 3))) 50) #t #f)))

;This function return resultant state when action is applied to input state
(define (apply-move state move) 
	(let ((newstate (list-copy state)))
	(cond ((string=? move "stay") (append (list (car state) (list-ref state 1) (list-ref state 2) 
						(- (list-ref state 3) 1) 's) (list-tail state 4))) 
		((string=? move "eat-passive") (list (car state) (list-ref state 1) (list-ref state 2) 
					(+ (- (list-ref state 3) 5) (return-vegetation state)))) 
		((string=? move "turn-right") (newdir newstate move)
			(append (list (car state) (list-ref state 1) (list-ref newstate 2) (- (list-ref state 3) 2) 'r)
						(list-tail state 4)))
		((string=? move "turn-around") (newdir newstate move)
			(append (list (car state) (list-ref state 1) (list-ref newstate 2) (- (list-ref state 3) 2) 'a)
						(list-tail state 4)))
		((string=? move "turn-left") (newdir newstate move)
			(append (list (car state) (list-ref state 1) (list-ref newstate 2) (- (list-ref state 3) 2) 'l)
						(list-tail state 4)))
		((string=? move "move-passive-1") (updatexy move newstate)
			(append (list (car newstate) (list-ref newstate 1) (list-ref state 2) (- (list-ref state 3) 10) 'm1)
						(list-tail state 4)))
		((string=? move "move-passive-2") (updatexy move newstate) 
			(append (list (car newstate) (list-ref newstate 1) (list-ref state 2) (- (list-ref state 3) 30) 'm2)
						(list-tail state 4)))
		((string=? move "move-passive-3") (updatexy move newstate) 
			(append (list (car newstate) (list-ref newstate 1) (list-ref state 2) (- (list-ref state 3) 60) 'm3) 
						(list-tail state 4))))))

;This function return all possible states possible on input state
(define (generate-moves state possible-actions)
	(cond ((null? possible-actions) '()) 
		((and (not(null? (generate-moves-helper state (car possible-actions)))) (null? (cdr possible-actions)))
				(list(generate-moves-helper state (car possible-actions))))
		((and (null? (generate-moves-helper state (car possible-actions))) (string=? (car possible-actions) "move-passive-1")) 
				(generate-moves state (cdddr possible-actions)))
		((and (null? (generate-moves-helper state (car possible-actions))) (string=? (car possible-actions) "move-passive-2")) 
				(generate-moves state (cddr possible-actions)))	
		((null? (generate-moves-helper state (car possible-actions))) 
				(generate-moves state (cdr possible-actions)))
		(#t	(append (list(generate-moves-helper state (car possible-actions))) (generate-moves state (cdr possible-actions))))))
	
(define (generate-moves-helper state action)
	(let ((newstate (list-copy (apply-move state action))))
		(cond ((string=? action "move-passive-3") 
			(if(and (not(null? (generate-moves-helper state "move-passive-1")))
				(not(null? (generate-moves-helper state "move-passive-2")))
				(eq? (array-ref grid (list-ref newstate 0) (list-ref newstate 1)) 1)	
				(eq? (array-ref vist (list-ref newstate 0) (list-ref newstate 1)) 0)
				(eq? (check-agent-pred newstate) #f)) newstate '()))
			((string=? action "move-passive-2")
			  (if(and (not(null? (generate-moves-helper state "move-passive-1")))
				  (eq? (array-ref grid (list-ref newstate 0) (list-ref newstate 1)) 1)	
				  (eq? (array-ref vist (list-ref newstate 0) (list-ref newstate 1)) 0)
				  (eq? (check-agent-pred newstate) #f)) newstate '()))
			(#t (if(and (eq? (array-ref grid (list-ref newstate 0) (list-ref newstate 1)) 1)	
				    (eq? (array-ref vist (list-ref newstate 0) (list-ref newstate 1)) 0)
				    (eq? (check-agent-pred newstate) #f)) newstate '())))))
			
; Utility Functions
(define energy-comparator 
	(lambda (c1 c2)
			(> (list-ref c1 3) (list-ref c2 3))))

(define (energy-sort state-list)
	(sort state-list energy-comparator))

(define (display-actions action)
	(cond ((eq? action 'ma1) "MOVE-AGGRESSIVE-1") 
		((eq? action 'ma2) "MOVE-AGGRESSIVE-2")
		((eq? action 'ma3) "MOVE-AGGRESSIVE-3")
		((eq? action 'm1) "MOVE-PASSIVE-1")
		((eq? action 'm2) "MOVE-PASSIVE-2")
		((eq? action 'm3) "MOVE-PASSIVE-3")
		((eq? action 'l) "TURN-LEFT")
		((eq? action 'r) "TURN-RIGHT")
		((eq? action 'a) "TURN-AROUND")
		((eq? action 's) "STAY")
		((eq? action 'ea) "EAT-AGGRESSIVE")
		((eq? action 'ep) "EAT-PASSIVE")))

; grid stores 1 - (empty, agent, predator), 0 - barrier, veg string - vegetation.
(define (check-move sym xloc yloc)
	(cond ((equal? sym 'empty) 1)
		((equal? sym 'agent) 
				(begin (add-cur-agent sym xloc yloc) 1))
		((equal? sym 'barrier) 0)
		((and (list? sym) (eq? (list-ref sym 0) 'vegetation))
			(begin (add-vegetation sym xloc yloc) sym))
		((and (list? sym) (eq? (list-ref sym 0) 'predator)) 
				(begin (add-cur-predator sym xloc yloc) 1))))

; This function generates solution path from input goal state.
(define (solution-path state) 
	(set! path (reverse (cons 'ep (list-tail state 4)))) 
	(set! path-length (length path)))

;This function parses the given percepts
(define (parse-percepts percepts)
	(let ((X  (car (car agent-state))) (Y (cadr (car agent-state))))
		(let oloop((i -1) (a 0) )
			(let iloop( (j i) (b 0))
			(array-set! grid (check-move (list-ref (list-ref percepts a) b) (+ X j) (+ Y i)) (+ X j) (+ Y i))
			(if (and (< j (abs i)) (< b 10)) (iloop (+ j 1) (+ b 1))))
			(if (and (> i -5) (< a 4)) (oloop (- i 1) (+ a 1))))))

(define (pp-e x y)
	(let oloop((i -1) (a 0) )
		(let iloop( (j i) (b 0))
		(array-set! grid (check-move (list-ref (list-ref percepts a) b) (+ x j) (+ y i)) (+ x j) (+ y i))
		(if (and (< j (abs i)) (< b 10)) (iloop (+ j 1) (+ b 1))))
		(if (and (> i -5) (< a 4)) (oloop (- i 1) (+ a 1)))))

(define (pp-w x y)
	(let oloop((i -1) (a 0) )
		(let iloop( (j i) (b 0))
		(array-set! grid (check-move (list-ref (list-ref percepts a) b) (+ x j) (+ y i)) (+ x j) (+ y i))
		(if (and (< j (abs i)) (< b 10)) (iloop (+ j 1) (+ b 1))))
		(if (and (> i -5) (< a 4)) (oloop (- i 1) (+ a 1)))))

(define (pp-s x y)
	(let oloop((i -1) (a 0) )
		(let iloop( (j i) (b 0))
		(array-set! grid (check-move (list-ref (list-ref percepts a) b) (+ x j) (+ y i)) (+ x j) (+ y i))
		(if (and (< j (abs i)) (< b 10)) (iloop (+ j 1) (+ b 1))))
		(if (and (> i -5) (< a 4)) (oloop (- i 1) (+ a 1)))))


;This function returns vegetation energy depending on agent's direction.
(define (return-vegetation state) 
	(let ((x (list-ref state 0)) (y (list-ref state 1)) (direc (list-ref state 2)) )
		(cond ((eq? direc 'n) (if(list? (array-ref grid x (- (cadr state) 1)))
						(caddr (array-ref grid x (- (cadr state) 1))) 0))
			((eq? direc 'e) (if(list? (array-ref grid (+ (car state) 1) y))
						(caddr (array-ref grid (+ (car state) 1) y)) 0))
			((eq? direc 'w) (if(list? (array-ref grid (- (car state) 1) y)) 
						(caddr (array-ref grid (- (car state) 1) y)) 0))
			((eq? direc 's) (if(list? (array-ref grid x (+ (cadr state) 1)))
						(caddr (array-ref grid x (+ (cadr state) 1))) 0)))))

;This function return new agent's direction depending on input move	
(define (newdir state move) 
	(let ((cur_dir (list-ref state 2))) 
	(cond ((and (string=? move "turn-right") (eq? cur_dir 'n)) (list-set! state 2 'e))
		((and (string=? move "turn-left") (eq? cur_dir 'n)) (list-set! state 2 'w))
		((and (string=? move "turn-around") (eq? cur_dir 'n)) (list-set! state 2 's))
		((and (string=? move "turn-right") (eq? cur_dir 'w)) (list-set! state 2 'n))
		((and (string=? move "turn-left") (eq? cur_dir 'w)) (list-set! state 2 's))
		((and (string=? move "turn-around") (eq? cur_dir 'w)) (list-set! state 2 'e))
		((and (string=? move "turn-right") (eq? cur_dir 'e)) (list-set! state 2 's))
		((and (string=? move "turn-left") (eq? cur_dir 'e)) (list-set! state 2 'n))
		((and (string=? move "turn-around") (eq? cur_dir 'e)) (list-set! state 2 'w))
		((and (string=? move "turn-right") (eq? cur_dir 's)) (list-set! state 2 'w))
		((and (string=? move "turn-left") (eq? cur_dir 's)) (list-set! state 2 'e))
		((and (string=? move "turn-around") (eq? cur_dir 's)) (list-set! state 2 'n)))))

(define (updatexy move state) 
	(cond ((and (string=? move "move-passive-1") (eq? (caddr state) 'n)) 
							(list-set! state 1 (- (list-ref state 1) 1)))
		((and (string=? move "move-passive-2") (eq? (caddr state) 'n)) 
							(list-set! state 1 (- (list-ref state 1) 2)))
		((and (string=? move "move-passive-3") (eq? (caddr state) 'n)) 
							(list-set! state 1 (- (list-ref state 1) 3)))
		((and (string=? move "move-passive-1") (eq? (caddr state) 'w)) 
							(list-set! state 0 (- (list-ref state 0) 1)))
		((and (string=? move "move-passive-2") (eq? (caddr state) 'w)) 
							(list-set! state 0 (- (list-ref state 0) 2)))
		((and (string=? move "move-passive-3") (eq? (caddr state) 'w)) 
							(list-set! state 0 (- (list-ref state 0) 3)))
		((and (string=? move "move-passive-1") (eq? (caddr state) 'e)) 
							(list-set! state 0 (+ 1 (list-ref state 0))))
		((and (string=? move "move-passive-2") (eq? (caddr state) 'e)) 
							(list-set! state 0 (+ 2 (list-ref state 0))))
		((and (string=? move "move-passive-3") (eq? (caddr state) 'e)) 
							(list-set! state 0 (+ 3 (list-ref state 0))))
		((and (string=? move "move-passive-1") (eq? (caddr state) 's)) 
							(list-set! state 1 (+ 1 (list-ref state 1))))
		((and (string=? move "move-passive-2") (eq? (caddr state) 's)) 
							(list-set! state 1 (+ 2 (list-ref state 1))))
		((and (string=? move "move-passive-3") (eq? (caddr state) 's)) 
							(list-set! state 1 (+ 3 (list-ref state 1))))))
